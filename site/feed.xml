<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-01-12T17:45:14+08:00</updated><id>/feed.xml</id><title type="html">瓜牛的世界</title><subtitle>小瓜牛飞啊飞...</subtitle><author><name>会飞的瓜牛</name></author><entry><title type="html">1</title><link href="/1/" rel="alternate" type="text/html" title="1" /><published>2025-01-11T00:00:00+08:00</published><updated>2025-01-11T00:00:00+08:00</updated><id>/1</id><content type="html" xml:base="/1/"><![CDATA[<h1 id="hello">hello</h1>
<p>hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld</p>]]></content><author><name>会飞的瓜牛</name></author><summary type="html"><![CDATA[hello hello wowrld hello wowrld hello wowrld hello wowrld hello wowrld]]></summary></entry><entry><title type="html">2</title><link href="/2/" rel="alternate" type="text/html" title="2" /><published>2025-01-11T00:00:00+08:00</published><updated>2025-01-11T00:00:00+08:00</updated><id>/2</id><content type="html" xml:base="/2/"><![CDATA[<h1 id="hello">hello</h1>
<p>hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld</p>]]></content><author><name>会飞的瓜牛</name></author><summary type="html"><![CDATA[hello hello wowrld hello wowrld hello wowrld hello wowrld hello wowrld]]></summary></entry><entry><title type="html">3</title><link href="/3/" rel="alternate" type="text/html" title="3" /><published>2025-01-11T00:00:00+08:00</published><updated>2025-01-11T00:00:00+08:00</updated><id>/3</id><content type="html" xml:base="/3/"><![CDATA[<h1 id="hello">hello</h1>
<p>hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld</p>]]></content><author><name>会飞的瓜牛</name></author><summary type="html"><![CDATA[hello hello wowrld hello wowrld hello wowrld hello wowrld hello wowrld]]></summary></entry><entry><title type="html">4</title><link href="/4/" rel="alternate" type="text/html" title="4" /><published>2025-01-11T00:00:00+08:00</published><updated>2025-01-11T00:00:00+08:00</updated><id>/4</id><content type="html" xml:base="/4/"><![CDATA[<h1 id="hello">hello</h1>
<p>hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld</p>]]></content><author><name>会飞的瓜牛</name></author><summary type="html"><![CDATA[hello hello wowrld hello wowrld hello wowrld hello wowrld hello wowrld]]></summary></entry><entry><title type="html">5</title><link href="/5/" rel="alternate" type="text/html" title="5" /><published>2025-01-11T00:00:00+08:00</published><updated>2025-01-11T00:00:00+08:00</updated><id>/5</id><content type="html" xml:base="/5/"><![CDATA[<h1 id="hello">hello</h1>
<p>hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld</p>]]></content><author><name>会飞的瓜牛</name></author><summary type="html"><![CDATA[hello hello wowrld hello wowrld hello wowrld hello wowrld hello wowrld]]></summary></entry><entry><title type="html">6</title><link href="/6/" rel="alternate" type="text/html" title="6" /><published>2025-01-11T00:00:00+08:00</published><updated>2025-01-11T00:00:00+08:00</updated><id>/6</id><content type="html" xml:base="/6/"><![CDATA[<h1 id="hello">hello</h1>
<p>hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld<br />
hello wowrld</p>]]></content><author><name>会飞的瓜牛</name></author><summary type="html"><![CDATA[hello hello wowrld hello wowrld hello wowrld hello wowrld hello wowrld]]></summary></entry><entry><title type="html">Hash_in_c</title><link href="/hash_in_c/" rel="alternate" type="text/html" title="Hash_in_c" /><published>2025-01-11T00:00:00+08:00</published><updated>2025-01-11T00:00:00+08:00</updated><id>/hash_in_c</id><content type="html" xml:base="/hash_in_c/"><![CDATA[<h1 id="c语言中巧用哈希">C语言中巧用哈希</h1>
<h2 id="前言">前言</h2>
<p> 今天在刷 <strong>leetcode</strong> 的时候遇到一个 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">简单题目</a>，要求求出字符串中的最大的不重复字符的字串长度。<br />
 这个题目本身不难，但是在处理如何判断某个字符是否已经出现过的问题上，就出现了问题。看了下其他语言都可以使用自带的 <strong>哈希</strong> 来解决这个问题，但是 c 呢，就有点难搞了。当然也有为 c 开发的第三方库，但是如何自己解决呢？——我想的是用数组，没错，就是 <strong>整形数组</strong></p>
<h2 id="整体思路">整体思路</h2>
<ul>
  <li>问题转化
    <ul>
      <li>将对符号的标记转化为对数字的标记</li>
      <li>将对数字的标记再转化为对变量数位的标记——独热</li>
    </ul>
  </li>
  <li>通过位操作完成对某个特定位的标记和检测</li>
</ul>

<h2 id="原理">原理</h2>
<h3 id="问题转化过程">问题转化过程</h3>
<ul>
  <li>将对<strong>符号</strong>的标记转变为对<strong>数字</strong>的标记<br />
在哈希中，要求键值对之间是1对1的关系。在 ASCII 中，她的编号和符号之间也是一对一的关系。有了这样的对应关系，我们就可以把题目要求的符号的标记问题，转换为对数字的处理。</li>
  <li>将对<strong>数字</strong>的标记转换为对整形变量<strong>位</strong>的标记<br />
如果想标记一个数字，是否出现过，最直接的办法是遍历，一个更快的办法是把数字转变为相应的位，让后通过 <strong>位操作</strong> 来处理，当然，这也是c语言的强项<br />
示例：
    <ol>
      <li>标记数字 8
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 初始化</span>
  <span class="n">hash</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="c1">//将 hash 的第8为设置为1,表示8存在过了</span>
</code></pre></div>        </div>
      </li>
      <li>判断 8 是否存在
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"8 已存在</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"8 还未被标记</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></div>        </div>
        <h3 id="单个整型变量的局限性">单个整型变量的局限性</h3>
      </li>
    </ol>
  </li>
  <li>无符号整形(unsigned int) 只有32位，那就意味着她能标记的范围是[1~32]——<strong>独热表示法</strong>, 如何标记大于32的数字呢？用数组。
    <h3 id="使用无符号整型数组扩展可以标记的数字的上限">使用无符号整型数组扩展可以标记的数字的上限</h3>
  </li>
  <li>单个变量中标记数字时，可以直接将数字想象称在整型变量中的数位，在数组中，则需要知道应该在数字在整个数组中的数位,那么，可以这么办——通过整除确定数组下标，通过取余知道在整型变量中数位。<br />
示例：标记数字 120
    <ol>
      <li>确定数组大小:120/32 = 3….24，则整型数组大小可谓4</li>
      <li>标记
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">120</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="mi">120</span> <span class="o">%</span> <span class="mi">32</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">hash</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">position</span><span class="p">;</span>
</code></pre></div>        </div>
        <blockquote>
          <h1 id="note">NOTE</h1>
          <ol>
            <li>笔者在处理的过程中使用的是无符号整形变量，当然也可使使用其他类型，诸如<code class="language-plaintext highlighter-rouge">char, shot, long</code>等，处理思路都是一样的
              <h2 id="解题代码">解题代码</h2>
              <h3 id="接口">接口</h3>
              <p>```c
  int s_len; // 字符串长度
  int count; //最长不重复字符串的长度</p>
            </li>
          </ol>
        </blockquote>
      </li>
    </ol>

    <p>// ASSCII码总共128
  // 找偏移位:’x’
  // ‘x’ 字符相对 0 偏移为：’x’ - 0  = 120 -0 = 120
  // 对应 hash[]中字节的位置： index = 120 / 32 = 3
  // 对应 字节中位的位置：position = 120 $ 32 = 24
  // 则 x 可在hash中被标记：hash[index] |= 1«position
  unsigned int hash[4] = {0}; // 哈希 32 x 4 = 128</p>

    <p>count = 0;
  for (s_len = 0; *(s+s_len) != ‘\0’; s_len++); // 获得 s 的长度</p>

    <p>int r_ptr = 0; // 右边界指针
  int index; // 字符的索引
  int position; // 整型变量内部偏移
  char c;
  for (int i = 0; i &lt; s_len; i++) {</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 滑动左边界：取消对 s[i-1]的标记
  if (i &gt; 0) {
      c = s[i-1];
      index = (c - 0) / 32;
      position = (c - 0) % 32;
      hash[index] &amp;= ~((unsigned int)1&lt;&lt;position); //将 s[i]存于 hash中
  }

  for (; r_ptr &lt; s_len;) {
      c = s[r_ptr];

      index = (c - 0) / 32;
      position = (c - 0) % 32;
      if (hash[index] &amp; (unsigned int)1&lt;&lt;position) {
          break; //已经被标记过
      } else {
          hash[index] |= (unsigned int)1&lt;&lt;position; //将 s[r_ptr]存于 hash中
          r_ptr++; // 滑动右边界
      }
  }
	
  count = count &gt; r_ptr-i ? count : r_ptr-i;   }
</code></pre></div>    </div>

    <p>return count;
}</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>### 测试 
```c
#include &lt;stdio.h&gt;

struct data_type {
	char* s;
	int expected_value;
};
enum {
	caseBASE = -1,
	case1,
	case2,
	case3,
	case4,
	case5,
	caseTOP
};
struct data_type test_data[] = {
	[case1] = {"abcabcbb", 3},
	[case2] = {"bbbbb", 1},
	[case3] = {"pwwkew", 3},
	[case4] = {"sjdgisgjisg", 5},
	[case5] = {"abcABC,.ab", 8},
};

int main(int argc, char* argv[])
{
	
	char* s = NULL;
	int expected_value = 0;
	int ret = 0;
	for (int i = caseBASE + 1; i &lt; caseTOP; i++) {
		s = test_data[i].s;
		expected_value = test_data[i].expected_value;

		ret = lengthOfLongestSubstring(s);
		printf("testcase No.%d ", i);
		if (ret == expected_value) {
			printf("pass\n");
		} else {
			printf("=========================\n");
			printf("fail:ret=%d\n", ret);
			printf("expected_value:%d\n", expected_value);
			printf("=========================\n");
		}
	}
	return 0;
}
</code></pre></div></div>]]></content><author><name>会飞的瓜牛</name></author><summary type="html"><![CDATA[C语言中巧用哈希 前言  今天在刷 leetcode 的时候遇到一个 简单题目，要求求出字符串中的最大的不重复字符的字串长度。  这个题目本身不难，但是在处理如何判断某个字符是否已经出现过的问题上，就出现了问题。看了下其他语言都可以使用自带的 哈希 来解决这个问题，但是 c 呢，就有点难搞了。当然也有为 c 开发的第三方库，但是如何自己解决呢？——我想的是用数组，没错，就是 整形数组 整体思路 问题转化 将对符号的标记转化为对数字的标记 将对数字的标记再转化为对变量数位的标记——独热 通过位操作完成对某个特定位的标记和检测]]></summary></entry><entry><title type="html">测试博客</title><link href="/test-blog/" rel="alternate" type="text/html" title="测试博客" /><published>2025-01-11T00:00:00+08:00</published><updated>2025-01-11T00:00:00+08:00</updated><id>/test-blog</id><content type="html" xml:base="/test-blog/"><![CDATA[<h1 id="海绵宝宝">海绵宝宝</h1>
<h2 id="简介">简介</h2>
<p>《海绵宝宝》（英语：SpongeBob SquarePants，旧译《棉球方块》[b]）是一部美国喜剧动画剧集，自1999年在尼克儿童频道播出至今，是目前尼克频道最长寿的节目，亦是尼克卡通最长寿的卡通，不仅比先前同为尼克卡通的如《尿布一族》、《大头仔天空》、《猫狗》等卡通的集数还多，更是目前集数最多的尼克卡通，创始者斯蒂芬·海伦伯格是一名海洋生物学家兼动画师，他同时也是动画制作公司United Plankton Pictures的老板。</p>

<h2 id="场景介绍">场景介绍</h2>
<p>剧情场景设定于太平洋中，一座称为比奇堡的城市。这部动画除了绘制的卡通场景与人物之外，也会穿插一些真实事件或是人物，例如曾经演出海滩游侠与霹雳游侠的大卫·赫索霍夫，他以本人的身份特别出演了几集。但海绵宝宝的剧情内容基本上与海洋知识无关，甚至夸大到完全不合乎科学与常识，例如海底生火、海底洗澡、海底有湖（酷乐湖）、鱼在湖（酷乐湖）里溺水、海底建筑物起火燃烧等。</p>

<h2 id="播放频道">播放频道</h2>
<p>最早播放该剧集的电视频道是尼克儿童频道，在台湾最初由东森幼幼台在YOYO NICK时段首播，而后在东森综合台、超视和台湾尼克儿童频道也有播放。中国大陆由中央电视台综合频道、中央电视台少儿频道和五家卡通卫视（北京卡酷、江苏优漫、上海炫动、湖南金鹰、广东嘉佳）播出。香港于亚洲电视国际台播出英文版本，然后由本港台，ViuTV播出粤语版本[c]，然后由ViuTVsix播出，虽然《海绵宝宝》在香港有替换过播映电视台，但粤语版配音员一直是大致相同。</p>

<h2 id="发展">发展</h2>
<p>《海绵宝宝》从1999年起在美国尼克儿童频道开播至今已经超过20年，广受全球小朋友欢迎，目前于全球超过50国播出《海绵宝宝》并有其配音版，到现在，《海绵宝宝》已经荣获4项艾美奖（Emmy Awards）、6项安妮奖（Annie Awards）和18座儿童票选奖，迄今已推出过三部电影《海绵宝宝电影版》《海绵宝宝：海陆大出击》和《海绵宝宝：奔跑吧》，2017年首演其同名舞台剧，近年更推出了衍伸剧集《珊瑚营：海绵宝宝那些年》和《派大星秀》，目前已计划将会推出更多衍生剧集和电影[2]，而周边商品已经为尼克频道创造逾130亿美元的收入。</p>

<p>海绵宝宝也出了很多相关电玩、漫画、手机游戏、应用程序等商品，在世界各地的尼克主题游乐园都有其海绵宝宝主题的游乐设施。</p>

<h2 id="地点介绍">地点介绍</h2>
<p>故事场景设定于太平洋海底，一座称为比奇堡的城市。</p>

<h3 id="比奇堡-bikini-bottom">比奇堡 (Bikini Bottom)</h3>
<p>本剧的背景城市。大部分故事均以此为舞台展开。在央视版配音中先后被翻译为裤头村、比基尼海滩，最后与台湾版一致，称为“比奇堡”。</p>
<h3 id="菠萝屋菠萝屋pineapple-house">菠萝屋（菠萝屋）(Pineapple House)</h3>
<p>海绵宝宝和小蜗的家，是从某一艘船上掉落的菠萝。在整部《海绵宝宝》剧集中遭遇过两次破坏：
第一次在第五集《甜蜜的家》中，菠萝屋被线虫大队吃掉了留下种子，最后是海绵宝宝搬离前留下的眼泪滴入种子让菠萝屋快速发芽重新建造回来。
第二次在第一百七十集《菠萝屋腐败记》中，菠萝屋腐烂了，最后用菠萝罐头把菠萝屋快速建造回来。</p>
<h3 id="复活岛人像屋-easter-island-house">复活岛人像屋 (Easter Island House)</h3>
<p>章鱼哥的家，位于比奇堡郊外，海绵宝宝家和派大星家之间，外型为深蓝色复活岛人像。在某些剧集中似乎有自己的意识。</p>
<h3 id="石头屋-rock-house">石头屋 (Rock House)</h3>
<p>派大星的家，位于比奇堡郊外章鱼哥家隔壁。外型为红棕色半圆体石头，里面的家具、摆设几乎是由沙子堆成，其深度在不同剧集中亦有不同。</p>
<h3 id="树屋-tree-house">树屋 (Tree House)</h3>
<p>珊迪的家，里面充满空气而没有海水，以玻璃制成，里面有个树屋。海洋生物进入常需要戴上装水的头盔防止干燥。由树屋发明有限公司董事会投资，用以进行发明创造。（第四季第10集）</p>
<h3 id="船锚屋-anchor-house">船锚屋 (Anchor House)</h3>
<p>蟹老板和珍珍的家，外型为深蓝色船锚。</p>
<h3 id="蟹堡王-krusty-krab">蟹堡王 (Krusty Krab)</h3>
<p>蟹老板所经营的速食店，比奇堡著名的餐厅之一，主打食物是蟹黄堡（蟹黄堡），外观是一个龙虾陷阱的模样。海绵宝宝在此担任厨师，章鱼哥担任收银员。派大星、小蜗亦曾在此工作过。</p>
<h3 id="海之霸-chum-bucket">海之霸 (Chum Bucket)</h3>
<p>痞老板所经营的餐厅，同时也是痞老板和凯伦的住所，主打食物是海霸棒及海霸糊，外观是一个水桶的模样，位于蟹堡王正对面。由于食物难吃加上卫生状况极差，绝大部分剧集中都少有人光顾。</p>
<h3 id="泡芙老师的海底驾训班-mrs-puffs-boating-school">泡芙老师的海底驾训班 (Mrs. Puff’s Boating School)</h3>
<p>泡芙老师在此教授驾训课程，也是海绵宝宝学习驾船的地方。但海绵宝宝不仅每次考试都过不了关拿不到驾照，还时常将驾校乃至整个比奇堡破坏殆尽。（央视版称其为“滑浪学校”）</p>
<h3 id="沙沙礁岩安养中心-shady-shoals">沙沙礁岩安养中心 (Shady Shoals)</h3>
<p>海超人和大洋游侠所居住的中价位安养中心。</p>
<h3 id="手套乐园-tunnel-of-glove">手套乐园 (Tunnel of Glove)</h3>
<p>比奇堡的游乐园。在第八季《再见，手套乐园》一集中因设备老旧而被封锁，又在旁边重建了手套酷乐园。</p>
<h3 id="水母田-jellyfish-fields">水母田 (Jellyfish Fields)</h3>
<p>海绵宝宝和派大星常去抓水母的地方，也是许多水母和蛤蛎的栖息地，每年都会有一次水母大迁徙。在第七季《力挽狂澜》中一度被改建为公路，后重新恢复为水母田。</p>
<h3 id="酷乐湖-goo-lagoon">酷乐湖 (Goo Lagoon)</h3>
<p>又名海边，比奇堡的海滩，消遣游玩胜地，湖底有危险巨大的泡泡糊。</p>
<h3 id="无底洞旧译噗噗镇rock-bottom">无底洞（旧译“噗噗镇”）(Rock Bottom)</h3>
<p>央视翻译为“石头滩”。最早出自第一季《我要回家》，位于比奇堡的下方的深海平原，那里的文字和居民千奇百怪，人民都用吐舌头沟通。</p>
<h3 id="纽开普市-new-cape-city">纽开普市 (New Cape City)</h3>
<p>都市名。那里的居民都很害怕刺破泡泡红眼帮，所以都不敢接近泡泡。海绵宝宝用泡泡打败刺破泡泡红眼帮后，当上了纽开普市市长，并鼓励所有市民开始吹泡泡。结果反而造成大灾难。（出自第五季《失踪记》）</p>
<h2 id="事物">事物</h2>
<h3 id="一般事物">一般事物</h3>
<ul>
  <li>空手道<br />
是海绵宝宝和珊迪喜欢玩的游戏。</li>
  <li>捉水母（Jellyfishing）<br />
海绵宝宝和派大星去水母田做的活动。</li>
  <li>全自动强力锅铲<br />
简称铲铲，在海绵宝宝刚进蟹堡王餐厅工作时，蟹老板要他买还附有全套旋转附件和涡轮动力。</li>
  <li>竖笛<br />
章鱼哥所使用的乐器。</li>
  <li>BBN（Bikini Bottom News）<br />
鲍伯、芭芭拉和金恩主持的一个新闻节目。</li>
  <li>泡泡糊<br />
呈紫色、不明物体、有毒、黏性强、可塑性强，可用泡泡水消除，出现在酷乐湖底的大缺口。（可能是死水母的尸体）</li>
  <li>蟹堡秘方<br />
蟹黄堡的祖传秘方，痞老板认为蟹堡秘方在蟹堡王办公室的保险箱里，但事实上在第三季第58集《痞老板的军队》中诉说在船锚屋（蟹老板和珍珍的家）中蟹老板的床垫下面。</li>
</ul>]]></content><author><name>会飞的瓜牛</name></author><category term="test" /><summary type="html"><![CDATA[海绵宝宝 简介 《海绵宝宝》（英语：SpongeBob SquarePants，旧译《棉球方块》[b]）是一部美国喜剧动画剧集，自1999年在尼克儿童频道播出至今，是目前尼克频道最长寿的节目，亦是尼克卡通最长寿的卡通，不仅比先前同为尼克卡通的如《尿布一族》、《大头仔天空》、《猫狗》等卡通的集数还多，更是目前集数最多的尼克卡通，创始者斯蒂芬·海伦伯格是一名海洋生物学家兼动画师，他同时也是动画制作公司United Plankton Pictures的老板。]]></summary></entry></feed>